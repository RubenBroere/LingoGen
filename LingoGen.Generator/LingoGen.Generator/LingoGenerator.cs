using LingoGen.Generator.DataTypes;
using Microsoft.CodeAnalysis;

namespace LingoGen.Generator;

[Generator(LanguageNames.CSharp)]
public class LingoGenerator : IIncrementalGenerator
{
    public const string Namespace = "LingoGen";

    private static string LingoBaseSource =>
        $$"""
          // <auto-generated/>

          using System.Globalization;

          namespace {{Namespace}};

          /// <summary>
          /// Static class containing all lingo entries.
          /// </summary>
          public static partial class Lingo
          {

          }
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Initialize the compilation with the lingo class 
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource("Lingo.g.cs", LingoBaseSource));

        // Cache file contents
        var lingoFiles = context.AdditionalTextsProvider
            .Where(static x => Path.GetFileName(x.Path) == "lingo.json")
            .Select(static (x, ct) => ((string Path, string Content))(x.Path, x.GetText(ct)?.ToString())!)
            .Where(static x => x.Content is not null);

        // Bool to indicate if there are no files
        var noFiles = lingoFiles.Collect().Select((x, _) => x.IsEmpty);

        var codeModel = lingoFiles.Select((x, ct) =>
        {
            var (entries, errors) = LingoDataParser.ParseLingo(x.Content, ct);

            return new GenerateCodeModel
            {
                FilePath = x.Path,
                Entries = entries,
                Errors = errors
            };
        });

        // TODO: Cache lingo entries

        context.RegisterSourceOutput(codeModel.Combine(noFiles), GenerateCode);
    }

    private static void GenerateCode(SourceProductionContext ctx, (GenerateCodeModel model, bool noFiles) input)
    {
        var (model, noFiles) = input;

        if (noFiles)
        {
            ctx.ReportDiagnostic(Diagnostic.Create(Diagnostics.NoJsonWarning, Location.None));
            return;
        }

        if (!model.Entries.Any())
        {
            ctx.ReportDiagnostic(Diagnostic.Create(Diagnostics.NoEntriesWarning, Location.Create(model.FilePath, new(), new()), model.FilePath));
            return;
        }

        foreach (var error in model.Errors)
        {
            ctx.ReportDiagnostic(Diagnostics.FromParserError(error, model.FilePath));
        }

        foreach (var entry in model.Entries)
        {
            var source = LingoClass.Build(entry, model.FilePath);
            ctx.AddSource($"Lingo.{entry.FullPath}.g.cs", source);
        }
    }
}

public class GenerateCodeModel
{
    public string FilePath { get; set; } = "";

    public IEnumerable<LingoEntry> Entries { get; set; } = [];

    public IEnumerable<LingoParserError> Errors { get; set; } = [];
}