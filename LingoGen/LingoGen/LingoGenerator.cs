using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Newtonsoft.Json;
using System.Threading;
using Microsoft.CodeAnalysis;

namespace LingoGen;

[Generator]
public class LingoGenerator : IIncrementalGenerator
{
    private const string Namespace = "LingoGen";

    private static string TranslationSourceCode =>
        $$"""
          // <auto-generated/>

          using System.Globalization;

          namespace {{Namespace}};

          public static partial class Lingo
          {

          }
          """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Initialize the compilation with the lingo class 
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource("Lingo.g.cs", TranslationSourceCode));

        var entries = context.AdditionalTextsProvider.SelectMany(ParseLingoEntries);

        context.RegisterSourceOutput(entries, GenerateCode);
    }

    private static void GenerateCode(SourceProductionContext ctx, LingoEntry entry)
    {
        var translations = new StringBuilder();

        if (entry.Translations is not null)
        {
            foreach (var x in entry.Translations)
            {
                translations.AppendLine($"        \"{x.Key}\" => \"{x.Value}\",");
            }
        }

        var source =
            $$"""
              // <auto-generated/>

              using System;
              using System.Globalization;

              namespace {{Namespace}};

              public static partial class Lingo
              {
                  public static string {{entry.Key}} => CultureInfo.CurrentUICulture.TwoLetterISOLanguageName switch
                  {
              {{translations}}
                      _ => $"{CultureInfo.CurrentUICulture.TwoLetterISOLanguageName}:{{entry.Key}}"
                  };
              }
              """;

        ctx.AddSource($"Lingo.{entry.Key}.g.cs", source);
    }

    private static IEnumerable<LingoEntry> ParseLingoEntries(AdditionalText text, CancellationToken cancellationToken)
    {
        var json = ParseLingoJson(text);
        return ParseLingoEntries(json);
    }

    private static LingoJson? ParseLingoJson(AdditionalText text)
    {
        // Check if the file name is the specific file that we expect.
        if (Path.GetFileName(text.Path) != "lingo.json")
            return null;

        var json = text.GetText();

        if (json is null)
            return null;

        var lingoJson = JsonConvert.DeserializeObject<LingoJson>(json.ToString());

        return lingoJson ?? null;
    }

    private static IEnumerable<LingoEntry> ParseLingoEntries(LingoJson? lingoJson)
    {
        if (lingoJson?.Entries == null)
            return [];

        return lingoJson.Entries.Select(translation => new LingoEntry
        {
            Key = translation.Key,
            Translations = translation.Value
        });
    }
}

public class LingoJson
{
    public Dictionary<string, Dictionary<string, string>>? Entries { get; set; }
}

public sealed class LingoEntry
{
    public string Key { get; set; } = default!;

    public Dictionary<string, string>? Translations { get; set; }
}

public sealed class LingoEntryComparer : IEqualityComparer<LingoEntry>
{
    public bool Equals(LingoEntry x, LingoEntry y)
    {
        var sameKey = x.Key == y.Key;

        if (!sameKey ||
            x.Translations is null && y.Translations is not null ||
            x.Translations is not null && y.Translations is null)
            return false;

        if (x.Translations is null && y.Translations is null)
            return sameKey;

        if (x.Translations!.Count != y.Translations!.Count)
            return false;

        foreach (var translation in y.Translations)
        {
            if (!x.Translations.TryGetValue(translation.Key, out var value))
                return false;

            if (value != translation.Value)
                return false;
        }

        return true;
    }

    public int GetHashCode(LingoEntry obj)
    {
        // TODO: Implement a better hash code
        return obj.Key.GetHashCode();
    }
}