using System.Collections.Immutable;
using System.IO;
using Microsoft.CodeAnalysis;

namespace LingoGen;

[Generator]
public class LingoGenerator : IIncrementalGenerator
{
    public const string Namespace = "LingoGen";

    private static string LingoBaseSource =>
        $$"""
          // <auto-generated/>

          using System.Globalization;

          namespace {{Namespace}};

          /// <summary>
          /// Static class containing all lingo entries.
          /// </summary>
          public static partial class Lingo
          {

          }
          """;

    private static readonly DiagnosticDescriptor NoEntriesWarning = new("LG1001",
        "LG1001: No entries in lingo.json",
        "LG1001: No entries in {0}",
        "LingoGen",
        DiagnosticSeverity.Warning,
        true);

    private static readonly DiagnosticDescriptor NoJsonWarning = new("LG1000",
        "LG1000: No lingo.json file found",
        "LG1000: No lingo.json file found",
        "LingoGen",
        DiagnosticSeverity.Warning,
        true);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Initialize the compilation with the lingo class 
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource("Lingo.g.cs", LingoBaseSource));

        // Cache file contents
        var lingoFiles = context.AdditionalTextsProvider
            .Where(static additionalText => Path.GetFileName(additionalText.Path) == "lingo.json");

        var lingoTexts = lingoFiles
            .Select(static (additionalText, ct) => additionalText.GetText(ct)?.ToString())
            .Where(static text => text is not null);

        var noFiles = lingoFiles.Collect().Select((x, _) => x.IsEmpty);

        // Cache lingo entries
        var lingoEntries = lingoTexts
            .SelectMany(static (content, _) => LingoEntryParser.ParseLingo(content!))
            .WithComparer(new LingoEntryComparer());

        context.RegisterSourceOutput(lingoEntries.Collect().Combine(noFiles), GenerateCode);
    }

    private static void GenerateCode(SourceProductionContext ctx, (ImmutableArray<LingoEntry> entries, bool noFiles) input)
    {
        var (entries, noFiles) = input;

        if (noFiles)
        {
            ctx.ReportDiagnostic(Diagnostic.Create(NoJsonWarning, Location.None));
            return;
        }

        if (entries.IsEmpty)
        {
            ctx.ReportDiagnostic(Diagnostic.Create(NoEntriesWarning, Location.None));
            return;
        }

        foreach (var entry in entries)
        {
            var source = LingoClass.Build(entry.Path, entry.Translations);
            ctx.AddSource($"Lingo.{entry.Path}.g.cs", source);
        }
    }
}