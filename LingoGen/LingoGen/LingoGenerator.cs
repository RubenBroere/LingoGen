using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Threading;
using Microsoft.CodeAnalysis;

namespace LingoGen;

public class LingoGenerator : IIncrementalGenerator
{
    private const string Namespace = "Generators";

    private const string TranslationSourceCode = $$"""
                                                   // <auto-generated/>

                                                   namespace {{Namespace}}
                                                   {
                                                      public static partial class Lingo
                                                      {
                                                         public const string Test = "Lingo";
                                                      }
                                                   }
                                                   """;


    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Initialize the compilation with the lingo class 
        // context.RegisterPostInitializationOutput(ctx => ctx.AddSource("Lingo.g.cs", TranslationSourceCode));

        // Get the lingo.json contents
        var fileContents = context.AdditionalTextsProvider.Where(static t => Path.GetFileName(t.Path) == "lingo.json").Select((x, _) => x.GetText());

        var keys = fileContents.SelectMany(static (x, _) =>
        {
            if (x is null)
                return Enumerable.Empty<string>();

            var lingoJson = JsonSerializer.Deserialize<LingoJson>(x.ToString());

            return lingoJson?.Entries?.Keys ?? Enumerable.Empty<string>();
        });

        context.RegisterSourceOutput(keys, (ctx, key) =>
        {
            ctx.AddSource($"Lingo.{key}.g.cs",
                $$"""
                  // <auto-generated/>

                  public static partial class Lingo
                  {
                      public const string {{key}} = "";
                  }
                  """);
        });

        var lingoEntries = context.AdditionalTextsProvider.SelectMany(ParseLingoEntries);

        // context.RegisterSourceOutput(lingoEntries, GenerateCode);
    }

    private static IEnumerable<LingoEntry> ParseLingoEntries(AdditionalText text, CancellationToken cancellationToken)
    {
        var json = ParseLingoJson(text);
        return ParseLingoEntries(json);
    }

    private static LingoJson? ParseLingoJson(AdditionalText text)
    {
        // Check if the file name is the specific file that we expect.
        if (Path.GetFileName(text.Path) != "lingo.json")
            return null;

        var json = text.GetText();

        if (json is null)
            return null;

        var lingoJson = JsonSerializer.Deserialize<LingoJson>(json.ToString());

        return lingoJson ?? null;
    }

    private static IEnumerable<LingoEntry> ParseLingoEntries(LingoJson? lingoJson)
    {
        if (lingoJson?.Entries == null)
            return [];

        return lingoJson.Entries.Select(translation => new LingoEntry
        {
            Key = translation.Key,
            Translations = translation.Value
        });
    }
}

public class LingoJson
{
    public Dictionary<string, Dictionary<string, string>>? Entries { get; set; }
}

public sealed class LingoEntry
{
    public string Key { get; set; } = default!;

    public Dictionary<string, string>? Translations { get; set; }
}

public sealed class LingoEntryComparer : IEqualityComparer<LingoEntry>
{
    public bool Equals(LingoEntry x, LingoEntry y)
    {
        var sameKey = x.Key == y.Key;

        if (!sameKey || 
            x.Translations is null && y.Translations is not null || 
            x.Translations is not null && y.Translations is null)
            return false;

        if (x.Translations is null && y.Translations is null)
            return sameKey;

        if (x.Translations!.Count != y.Translations!.Count)
            return false;

        foreach (var translation in y.Translations)
        {
            if (!x.Translations.TryGetValue(translation.Key, out var value))
                return false;

            if (value != translation.Value)
                return false;
        }

        return true;
    }

    public int GetHashCode(LingoEntry obj)
    {
        // TODO: Implement a better hash code
        return obj.Key.GetHashCode();
    }
}